{
  "name": "asyncjs",
  "description": "async.js it for the node fs module, what jQuery is for the DOM",
  "version": "0.0.9",
  "homepage": "http://github.com/fjakobs/async.js",
  "engines": {
    "node": ">= 0.4.0"
  },
  "author": {
    "name": "Fabian Jakobs",
    "email": "fabian.jakobs@web.de"
  },
  "scripts": {
    "test": "node test/all.js"
  },
  "main": "index",
  "repository": {
    "type": "git",
    "url": "http://github.com/fjakobs/async.js.git"
  },
  "licenses": [
    {
      "type": "The MIT License",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "readme": "async.js\n========\n\n**A clean, composable way to manipulate sequences of values with asynchronous functions\n**\n\nDealing with control flow in heavily asynchronous code can be a big challange. Without any helper functions the code can easily degenerate into a christmas tree shape because of the callback of a callback of a callback syndrome.\n\n```js\n    asncFunction1(function(err, result) {\n        asncFunction2(function(err, result) {\n            asncFunction3(function(err, result) {\n                asncFunction4(function(err, result) {\n                    asncFunction5(function(err, result) {\n                        // do something useful\n                    })\n                })\n            })\n        })\n    })\n```    \n\nWith async.js this can be written as\n```js\n    async.list([\n        asncFunction1,\n        asncFunction2,\n        asncFunction3,\n        asncFunction4,\n        asncFunction5,\n    ]).call().end(function(err, result) {\n        // do something useful\n    });\n```\nIt gets even worse if an asynchronous function has to be applied to a sequence of values. There is a nice example of this in the  howtonode.org article [Control Flow in Node Part III](http://howtonode.org/control-flow-part-iii):\n```js\n    // Here is the async version without helpers\n    function loaddir(path, callback) {\n      fs.readdir(path, function (err, filenames) {\n        if (err) { callback(err); return; }\n        var realfiles = [];\n        var count = filenames.length;\n        filenames.forEach(function (filename) {\n          fs.stat(filename, function (err, stat) {\n            if (err) { callback(err); return; }\n            if (stat.isFile()) {\n              realfiles.push(filename);\n            }\n            count--;\n            if (count === 0) {\n              var results = [];\n              realfiles.forEach(function (filename) {\n                fs.readFile(filename, function (err, data) {\n                  if (err) { callback(err); return; }\n                  results.push(data);\n                  if (results.length === realfiles.length) {\n                    callback(null, results);\n                  };\n                });\n              });\n            }\n          });\n        });\n      });\n    }\n```    \nThis code reads the contents of a directory, filters out all directory and returns the contens of all files as an array. Without any helpers the whole control flow management totally obscures the intent of the code. With async.js it is possible to move the control flow aspects of the code out of the function and rewrite it like this:\n```js\n    function loaddir(path, callback) {\n        async.readdir(\".\")\n            .stat()\n            .filter(function(file) {\n                return file.stat.isFile()\n            })\n            .readFile(\"utf8\")\n            .filter(function(file) {\n                return file.data\n            })\n            .toString(callback)\n    }\n```    \n\nFeatures\n========\n\nCore\n----\n\nJavaScript Array like abstraction, which supports almost all JavaScript array functions with asynchronous versions of\n\n- filter\n- map\n- reduce\n- forEach\n- some\n- every\n\nAll functions are chainable.\n\nnode.js file system plugin\n--------------------------\n\nMost of the functions from the `fs` module in node.js are exposed as chainable filters.\n\n- `stat` (lstat, fstat)\n- `unlink`\n- `mkdir`/`rmdir`\n- `realpath`\n- `open`/`close`\n- `exists` (from `path.exists`)\n- `chmod`\n- `readFile`/`writeFile`\n\nConstructors\n\n- `files`: convert a list of files into a file sequence\n- `readdir`: create a file sequence from the files in a directory\n- `walkfiles`: recursive file walker\n- `glob`: Unix style file matching. Creates a file sequence of all matching files.\n\nUtility functions to work with the file system\n\n- `abspath`: convert a relative to an absolute path\n- `copyfile`: copy a single file\n- `copytree`: copy whole diroctory tree\n- `rmtree`: remove whole direcory tree (like `rm -rf`)\n\nUtils plugin\n------------\n\nGeneric filters:\n\n- `delay`: wait a given time before returning the next value\n- `timeout`: If the source doesn't respond in a given time an error is returned.\n- `inspect`: print the source value as JSON\n- `print`: print the source value as string\n\nHow does it work?\n=================\n\n## Constructors\n\nConstructors are the sources of async streams. They return an `async.Generator` instance which generates a sequence of values.\n\n## Filters\n\nFilters work on the sequence generated by a source generator. They can remove, add and modify values in the sequence. Filters return themselves generator instances.\n\n## Drivers\n\nDriver methods drive the actual execution of the iteration. The hole system is based on the principle of pulling the values from the end. Until any of the drivers is called no value will be generated.\n\n\nTODO\n====\n\n- Add documentation about the fs plugin\n- Add documentation about the unit testing framework\n- improve test coverage of the core functionality\n- create browser version\n\nContinuous Integration status\n-----------------------------\n\nThis project is tested with [Travis CI](http://travis-ci.org)\n[![Build Status](https://secure.travis-ci.org/fjakobs/async.js.png)](http://travis-ci.org/fjakobs/async.js)\n\nCore API\n========\n\n## Constructors\n\n### async.range([start=0], [stop], [step=1], [construct=async.Generator])\n\nCreates a generator generating an arithmetic progression of integers.\n`range(i, j)` returns [i, i+1, i+2, ..., j-1] and `start` defaults to 0.\nWhen step is given, it specifies the increment (or decrement). If `stop` is not given an infinite number of values if generated. This generates all positive odd numbers:\n```js\n    async.range(1, null, 2)\n```\nThe optional `construct` argument must be a sub class of `async.Generator` and can be used to tell the function to return instances of the class.\n\n\n### async.list(arr, [construct=async.Generator])\n\nCreates a generator, which returns the elements of the given array. This generates e.g. the values `1`, `2` and `3`:\n```js\n    async.list([1, 2, 3])\n```\nThe optional `construct` argument must be a sub class of `async.Generator` and can be used to tell the function to return instances of the class.\n\n\n## async.Generator(source)\n\nGenerators are implementing the 'Iterator' design pattern in an asynchronous way. It has a `next(callback)` method, which passes on each call the next generated value to the given callback. Generators can be chained and all construcors and filters return new `Generator` instances.\n\nThe `source` is either another `async.Generator` or a generator function. All filters in the generator operate on the values generated by the source.\n```js\n    var i=0;\n    var gen = new async.Generator(function(callback) {\n        if (i>4)\n            callback(async.STOP)\n        else\n            callback(null, i++) // no error\n    })\n```    \n`gen` in this example generates the sequence [0, 1, 2, 3, 4]. The first argument of the callback can be used to indicate an error the the end of the iteration, whicle the second argument is the generated value.\n\n### Constant: async.STOP\n\nSpecial error value, which indicates the end of the iteration.\n\n### Method: next(callback)\n\nCalls the callback with the next generated value:\n```js\n    gen.next(function(err, value) {\n        //\n    })\n```    \nThe generated value is passed in the `value` argument. If an error occured while computing the value the `err` argument is set. In this case value the meaning of value is undefined. `async.STOP` can be passed as special error value to indicate the end of the iteration.\n\nUsually this method is only needed to write custom filters.\n\n### Filter: map(mapper)\n\nApplies the `mapper` function to all values of the generator's source and generates the result of the mapping.\n```js\n    async.range(0, 3)\n        .map(function(item, next) {\n            next(null, item + 1)\n        })\n```    \nThis will add one to each incoming item and thus generate the sequence [1, 2, 3].\n\nThe mapper can also be synchronous and simply return the result. In this case the mapper must not have the `next` argument.\n\n\n### Filter: filter(filter)\n\nCalls filter for each of the generator's source values. If the `filter` returns `false` for a passed value, the value is dropped from the sequence, otherwise the value is forwarded.\n```js\n    async.list([1, 2, 3, 4])\n        .filter(function(item, next) {\n            next(null, item % 2 == 0)\n        })\n```        \nThis will filter out all odd values and generate the sequence [2, 4].\n\n\n### Filter: slice(begin, end)\n\nCounts the generator's source values starting with 0 and skips all values with an index smaller then `begin`. If the index is >= `end` the sequence is stopped.\n```js\n    async.range(0)\n        .slice(1, 4)\n```        \nThe `async.range` call generates an infinite sequence of all integers and the `slice` call transforms this into the sequence [1, 2, 3] by dropping the first value and stopping the sequence after the 4th value.\n\n### Filter: reduce(reduce, [initialValue])\n\nSum up the number from 1 to 5:\n```js\n    async.range(1, 5)\n        .reduce(function(previousValue, currentValue) {        \n            return previousValue + currentValue;\n        })\n```        \nSum up the number from 1 to 5 but with a first 'initialValue' of 10:\n```js\n    async.range(1, 5)\n        .reduce(function(previousValue, currentValue, index, next) {\n            next(null, previousValue + currentValue);\n        }, 10)\n```\n\n### Filter: forEach(fn)\n\nAlias for `each`.\n\n### Filter: each(fn)\n\nCalls `fn` for each of the source generator's values. The returned generator passes on the source values.\n```js\n    async.range(1, 10)\n        .each(function(item, next) {\n            console.log(item);\n        })\n```        \nPrints the numbers from 1 to 9. Otherwise the source sequence is not changed.\n\n### Filter: some(condition)\n\nCheck if any of the values in the source sequence match the condition (i.e. the `condition` callback returns true). The returned generator generates a one elmement sequence, which contains the boolean value of the result.\n\nCheck if the source generates an even number:\n```js\n    async.list([1, 8, 3, 5])\n        .some(function odd(item) {\n            return item % 2 == 0\n        })\n```\nThis generates [true].\n\n### Filter: every(condition)\n\nCheck if all of the values in the source sequence match the condition (i.e. the `condition` callback returns true). The returned generator generates a one elmement sequence, which contains the boolean value of the result.\n\nCheck if the source generates only even numbers:\n```js\n    async.list([1, 8, 3, 5])\n        .every(function odd(item) {\n            return item % 2 == 0\n        })\n```\nThis returns [false]\n\n### Filter: call([context])\n\nCalls each of source values in sequence, which have to be functions. The functions can either be synchronous and return a value of be asynchronous and call the passed callback on completion. The generated sequence are the function's return values. The optional `context` argument defines the `this` context of the called functions.\n```js\n    async.list([\n        function sync() {\n            return \"juhu\"\n        },    \n        function async(next) {\n            next(null, \"kinners\")\n        }\n    ]).call()\n```    \nThis calls the two functions in sequence and generates the sequence [\"juhu\", \"kinners\"].\n\n### Filter: concat(...)\n\nConcatenates a variable number of generators with this generator. \n```js\n    async.range(1, 4)\n        .concat(async.range(10, 13))\n```        \nThis returns a generator, which generates the values of the first `range` followed by the values of the second `range`: [1, 2, 3, 10, 11, 12]\n\n\n### Filter: zip(...)\n\nReturns a generator, which generates on each `next()` an arroy of the next values of this generator and each of the passed arguments. The length of the generated sequence is truncated to the lenght of the shortest input sequence. This function expects a variable list of generators as arguments.\n```js\n    async.range(1, 4)\n        .zip(async.range(10, 14))\n```        \nThis will generate [[1, 10], [2, 11], [3, 13]]\n\n### Filter: sort([compare])\n\nPerforms an Array.prototype.sort on the source values and returns a generator, which generates the result as one element sequence. Since this requires reading all source elements, the source must not generate an infinite number of values. Generates the read values in sorted order.\n```js\n    async.list([4, 2, 3, 9])\n        .sort()\n```\nThis generates the sequence [2, 3, 4, 9]\n\n### Filter: join([separator])\n\nPerforms an Array.prototype.join on the source values and returns a generator, which generates the result as one element sequence. Since this requires reading all source elements, the source must not generate an infinite number of values.\n```js\n    async.list([1, 4, 5])\n        .join(\" - \")\n```\nThis will generate [\"1 - 4 - 5\"]\n\n### Filter: reverse()\n\nReverses the elements generated by the generator's source. Since this requires reading all source elements, the source must not generate an infinite number of values.\n```js\nasync.list([1, 4, 5])\n    .revers()\n```\nThis will generate [5, 4, 1]\n\n\n### Driver: end([callback])\n\nPerform the iteration until the generator's source either returns `async.STOP` or indicates an error. The value of the last generated value is passed to the callback.\n\n```js\n    async.list([1, 8, 3, 5])\n        .every(function odd(item) {\n            return item % 2 == 0\n        })\n        .end(function(err, allEven) {\n            console.log(\"All values are even: \" + allEven)\n        }) \n```\nThis will print the last generated value (the result of `very`) on the console.\n\n### Driver: toArray([breakOnError=true], callback)\n\nPerform the iteration until the generator's source either returns `async.STOP`. If `breakOnError` is true the iteration is stopped on the first error. Otherwise the iteration continues and all errors are collected in an error array. An array of all generated values is passed to the callback.\n```js\n    async.list([1, 8, 3, 5])\n        .map(function odd(item, next) {\n            next(err, item * 10)\n        })\n        .toArray(function(err, values) {\n            console.log(values)\n        }) \n```\nThe last callback will be called with arr set to [10, 80, 30, 50].\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/fjakobs/async.js/issues"
  },
  "_id": "asyncjs@0.0.9",
  "dist": {
    "shasum": "d93d3f7359d13c49429b4df7f31160b68d5e950a"
  },
  "_from": "asyncjs@0.0.x",
  "_resolved": "https://registry.npmjs.org/asyncjs/-/asyncjs-0.0.9.tgz"
}
